<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>做对的事，不是把事情做对</title>
      <link href="/eric000.github.io/2024/08/18/%E5%81%9A%E5%AF%B9%E7%9A%84%E4%BA%8B/"/>
      <url>/eric000.github.io/2024/08/18/%E5%81%9A%E5%AF%B9%E7%9A%84%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="最近心态转变"><a href="#最近心态转变" class="headerlink" title="最近心态转变"></a>最近心态转变</h2><p>之前我很喜欢听一些心态或生活方面的经验与感悟，容易与他人产生共鸣。现在我更喜欢了解一些自己未曾接触过的知识盲区。虽然无法彻底理解其中的深奥文化，但感受他人的心得总能带来不一样的体验。</p><h2 id="01-学习总结"><a href="#01-学习总结" class="headerlink" title="01 学习总结"></a>01 学习总结</h2><p>我使用了三个插件：</p><ol><li>主题</li><li>快速语音笔记</li><li>自动注释的 C++ 插件</li></ol><p>        <span class="lazyload-img-span">        <img              data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/ekGqWs6vZmQUpmwGTrydHvfw4Hz40mpBN6w2wic5hGbLNHC1BibVq02ibObTDAAsHCpqqYnBjYJhnLF0h0RB1GzDg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload-img">        </sapn>      <br>        <span class="lazyload-img-span">        <img              data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/ekGqWs6vZmQUpmwGTrydHvfw4Hz40mpBiarAdXInubeFTLLozjvOlVGBFlckNia548qxF3IFPpgsxibUnRlj8Im7Q/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload-img">        </sapn>      </p><h2 id="02-认知"><a href="#02-认知" class="headerlink" title="02 认知"></a>02 认知</h2><p>我体会到赚钱其实是在赚信息差。很喜欢一句话：人生就像是一块块拼图，你可能只是随便丢下了几块拼图，但某一天不知不觉中你会发现某一块区域已经拼好了。这句话生动地表达了前进的意义，当下的努力是为未来的道路播种。</p><h2 id="03-最后"><a href="#03-最后" class="headerlink" title="03 最后"></a>03 最后</h2><p>不要失去输出内容的能力。内心获得很多感受，想给他人提供正反馈，却只能哑巴吃黄莲。有时候与他人共享想法能够获得双倍的价值。</p><p>        <span class="lazyload-img-span">        <img              data-src="https://mmbiz.qpic.cn/sz_mmbiz/ekGqWs6vZmQUpmwGTrydHvfw4Hz40mpBhJ48gOG7vhogNYibTU59FIn9mfQfhZvJibLjc47nqIsWmc2cIzyfTvIA/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload-img">        </sapn>      </p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希两数之和</title>
      <link href="/eric000.github.io/2024/08/12/%E5%93%88%E5%B8%8C%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/eric000.github.io/2024/08/12/%E5%93%88%E5%B8%8C%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：<br><br>输入：<br>nums &#x3D; [2,7,11,15], target &#x3D; 9<br><br>输出：<br>[0,1]<br><br>解释：<br>因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br><br><br>示例 2：<br><br>输入：<br>nums &#x3D; [3,2,4], target &#x3D; 6<br><br>输出：<br>[1,2]<br><br><br>示例 3：<br><br>输入：<br><br>nums &#x3D; [3,3], target &#x3D; 6<br>输出：<br>[0,1]<br><br><em>解题思路</em>：</p><p>        <span class="lazyload-img-span">        <img              data-src="https://i-blog.csdnimg.cn/direct/fea80c0efe074f58afa445c4a92b90fd.png" class="lazyload-img">        </sapn>      </p><br>ht[target-v]返回的是target-v位置的索引<p>用map存键和值，值是索引，键是数组的值</p><p>如果能找到，就返回索引对。</p><p><em>代码如下</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ht;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> v = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(ht.<span class="built_in">count</span>(target - v))&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i,ht[target-v]&#125;;            </span><br><span class="line">            &#125;</span><br><span class="line">            ht[v] =i; </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何制作动图链接</title>
      <link href="/eric000.github.io/2024/08/10/%E5%88%B6%E4%BD%9C%E5%8A%A8%E5%9B%BE%E9%93%BE%E6%8E%A5/"/>
      <url>/eric000.github.io/2024/08/10/%E5%88%B6%E4%BD%9C%E5%8A%A8%E5%9B%BE%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>1.打开网站</p><ul><li>Find &amp; Share on GIPHY</li></ul><p>2.注册登陆</p><p>3.点击右上角的upload<br>        <span class="lazyload-img-span">        <img              data-src="https://i-blog.csdnimg.cn/direct/f096efcf988a41348086b7cc357d75da.png" class="lazyload-img">        </sapn>      <br>4.上传gif或者mp4或者mov<br>        <span class="lazyload-img-span">        <img              data-src="https://i-blog.csdnimg.cn/direct/6dd9b7e17d6944488683ea9f11588029.png" class="lazyload-img">        </sapn>      <br>5.修改配置后点击continue<br>        <span class="lazyload-img-span">        <img              data-src="https://i-blog.csdnimg.cn/direct/09910a6f9c8f477a838fed5fc975842e.png" class="lazyload-img">        </sapn>      <br>6.点击upload<br>        <span class="lazyload-img-span">        <img              data-src="https://i-blog.csdnimg.cn/direct/4faa61f02db44efb9d035d2c6a3915f6.png" class="lazyload-img">        </sapn>      </p><p>7.点击share后选择 copy gif link<br>        <span class="lazyload-img-span">        <img              data-src="https://i-blog.csdnimg.cn/direct/4171233fe07543ea9c707133d92f7e78.png" class="lazyload-img">        </sapn>      </p><ol start="8"><li>打开vscode</li></ol><p>在vscode中这么使用即可</p><p>        <span class="lazyload-img-span">        <img              data-src="https://i-blog.csdnimg.cn/direct/d7887d8beaf74f88ac1573feba0d57ef.png" class="lazyload-img">        </sapn>      </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vscode插件图标显示</title>
      <link href="/eric000.github.io/2024/08/08/Vscode%E6%8F%92%E4%BB%B6%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA/"/>
      <url>/eric000.github.io/2024/08/08/Vscode%E6%8F%92%E4%BB%B6%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>首先在ts文件目录下和package.json同级的目录下加入一张图片，后缀是jpg、png、jpeg都可以。</p><p>然后package.json中加入该行<br>        <span class="lazyload-img-span">        <img              data-src="https://i-blog.csdnimg.cn/direct/e5a3e34dd14f41b5987f3e2a4b457352.png" class="lazyload-img">        </sapn>      </p><p>重新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsce package</span><br></pre></td></tr></table></figure><p>即可</p><p>如果出现报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The specified icon &#x27;xxx/xxx/icon.jpg&#x27; wasn&#x27;t found in the extension.</span><br></pre></td></tr></table></figure><p>那就是没有放正确文件夹的位置</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cities and States S--Map二维映射（C++完整代码）</title>
      <link href="/eric000.github.io/2024/08/04/Cities/"/>
      <url>/eric000.github.io/2024/08/04/Cities/</url>
      
        <content type="html"><![CDATA[<h2 id="USACO16DEC-Cities-and-States-S"><a href="#USACO16DEC-Cities-and-States-S" class="headerlink" title="[USACO16DEC] Cities and States S"></a>[USACO16DEC] Cities and States S</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Farmer John 有若干头奶牛。为了训练奶牛们的智力，Farmer John 在谷仓的墙上放了一张美国地图。地图上表明了每个城市及其所在州的代码（前两位大写字母）。</p><p>由于奶牛在谷仓里花了很多时间看这张地图，他们开始注意到一些奇怪的关系。例如，FLINT 的前两个字母就是 MIAMI 所在的 FL 州，MIAMI 的前两个字母则是 FLINT 所在的 MI 州。</p><p>确切地说，对于两个城市，它们的前两个字母互为对方所在州的名称。我们称两个城市是一个一对「特殊」的城市，如果他们具有上面的特性，并且来自不同的州。对于总共 N 座城市，奶牛想知道有多少对「特殊」的城市存在。请帮助他们解决这个有趣的地理难题！</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共 N + 1 行。第一行一个正整数 N，表示地图上的城市的个数。接下来 N 行，每行两个字符串，分别表示一个城市的名称（2 ∼ 10 个大写字母）和所在州的代码（2 个大写字母）。同一个州内不会有两个同名的城市。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共一行一个整数，代表特殊的城市对数。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6 MIAMI FL DALLAS TX FLINT MI CLEMSON SC BOSTON MA ORLANDO FL</span><br><span class="line"></span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>数据规模与约定：对于 100% 的数据，1 ≤ N ≤ 2 × 10^5，城市名称长度不超过 10。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先把多个字母的 a 只取前两个字母，只有当前缀和州名不同的时候才处理。</p><ol><li><a href="command:_github.copilot.openSymbolFromReferences?%5B%22st%5Ba%20%2B%20b%5D%2B%2B%3B%22%2C%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22%2FUsers%2Fggxxtt%2FDownloads%2Fhexo%2Fblog%2Fsource%2F_posts%2FCities.md%22%2C%22external%22%3A%22file%3A%2F%2F%2FUsers%2Fggxxtt%2FDownloads%2Fhexo%2Fblog%2Fsource%2F_posts%2FCities.md%22%2C%22path%22%3A%22%2FUsers%2Fggxxtt%2FDownloads%2Fhexo%2Fblog%2Fsource%2F_posts%2FCities.md%22%2C%22scheme%22%3A%22file%22%7D%2C%22pos%22%3A%7B%22line%22%3A52%2C%22character%22%3A2%7D%7D%5D%5D" title="Go to definition"><code>st[a + b]++;</code></a> 将城市前缀 a 和州名 b 组合起来作为键，记录或更新该组合出现的次数。</li><li><a href="command:_github.copilot.openSymbolFromReferences?%5B%22ans%20%2B%3D%20st%5Bb%20%2B%20a%5D%3B%22%2C%5B%7B%22uri%22%3A%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22%2FUsers%2Fggxxtt%2FDownloads%2Fhexo%2Fblog%2Fsource%2F_posts%2FCities.md%22%2C%22external%22%3A%22file%3A%2F%2F%2FUsers%2Fggxxtt%2FDownloads%2Fhexo%2Fblog%2Fsource%2F_posts%2FCities.md%22%2C%22path%22%3A%22%2FUsers%2Fggxxtt%2FDownloads%2Fhexo%2Fblog%2Fsource%2F_posts%2FCities.md%22%2C%22scheme%22%3A%22file%22%7D%2C%22pos%22%3A%7B%22line%22%3A53%2C%22character%22%3A2%7D%7D%5D%5D" title="Go to definition"><code>ans += st[b + a];</code></a> 检查是否有反向组合 b + a 已经存在，若存在则将其计数加到 ans 中。</li></ol><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><pre><code class="cpp">// C++ 代码示例#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;int main() &#123;    int N;    cin &gt;&gt; N;    unordered_map&lt;string, int&gt; st;    int ans = 0;    for (int i = 0; i &lt; N; i++) &#123;        string city, state;        cin &gt;&gt; city &gt;&gt; state;        string prefix = city.substr(0, 2);        st[prefix + state]++;        ans += st[state + prefix];    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>研发类</title>
      <link href="/eric000.github.io/2024/08/04/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E23%E6%A0%A1%E6%8B%9B%E7%A0%94%E5%8F%91%E7%B1%BB%EF%BC%88C++%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E9%81%93%E9%A2%98%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%89%E7%AC%AC%E4%BA%8C%E9%81%93%E9%A2%98%E6%B1%82%E5%8A%A9-%E5%9B%BE%E5%83%8F%E5%8F%A0%E5%8A%A0%E3%80%81%E4%B8%96%E7%95%8C%E6%9D%AF%E7%A7%AF%E5%88%86%E9%97%AE%E9%A2%98%E3%80%81%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/eric000.github.io/2024/08/04/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E23%E6%A0%A1%E6%8B%9B%E7%A0%94%E5%8F%91%E7%B1%BB%EF%BC%88C++%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E9%81%93%E9%A2%98%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%89%E7%AC%AC%E4%BA%8C%E9%81%93%E9%A2%98%E6%B1%82%E5%8A%A9-%E5%9B%BE%E5%83%8F%E5%8F%A0%E5%8A%A0%E3%80%81%E4%B8%96%E7%95%8C%E6%9D%AF%E7%A7%AF%E5%88%86%E9%97%AE%E9%A2%98%E3%80%81%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 图像叠加</strong></p><p>在图像应用程序中经常要将2个图层进行叠加，从而产生各种瑰丽的合成效果。现在请你实现常见的线性光叠加模式。</p><p>线性光叠加模式公式：C &#x3D; A + 2B - 255；C &lt; 0 时，取 C &#x3D; 0；C &gt; 255 时，取 C &#x3D; 255。</p><p>在公式中 A 代表下面图层的颜色值，也称为基色；B 代表上面图层的颜色值，也成为混合色；C 代表混合图层的颜色值，也称为结果色。</p><p>时间限制：C&#x2F;C++ 1秒，其他语言2秒<br>空间限制：C&#x2F;C++ 256M，其他语言512M  </p><p><strong>输入描述：</strong><br>第一行输入2个数字 M N，表示输入图片的大小（M、N 小于 1024）。<br>之后输入 M 行数据为 A 图像的数据内容，每行 N 个数字，表示该行的像素值。<br>之后继续输入 M 行数据为 B 图像的数据内容，每行 N 个数字，表示该行的像素值。  </p><p><strong>输出描述：</strong><br>M 行数据，每行 N 个数字，表示结果图片像素值。</p><p><strong>示例1</strong><br>输入例子：<br><br>2 2 100 200 50 50 50 50 100 100</p><p>输出例子：<br><br>0 45 0 0</p><p><strong>示例2</strong><br>输入例子：<br><br>2 3 23 172 238 238 174 151 22 117 230 230 237 141</p><p>输出例子：<br><br>0 151 255 255 255 178</p><p><strong>代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> M, N;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> res[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; M &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            cin &gt;&gt; b[i][j];</span><br><span class="line">            res[i][j] = a[i][j] + <span class="number">2</span> * b[i][j] - <span class="number">255</span>;</span><br><span class="line">            <span class="keyword">if</span> (res[i][j] &lt; <span class="number">0</span>) res[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (res[i][j] &gt; <span class="number">255</span>) res[i][j] = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            cout &lt;&lt; res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>直角三角形的个数</li></ol><p>二维平面直角坐标系中有 N 个整型坐标点 (x1, y1), (x2, y2), …, (xN, yN)，任意三个点都可能构成一个三角形，计算这些三角形中直角三角形的个数。</p><p>时间限制：C&#x2F;C++ 1秒，其他语言2秒<br>空间限制：C&#x2F;C++ 32M，其他语言64M</p><p>输入描述：<br>输入有两行：<br>第一行为 N，3 ≤ N ≤ 256。<br>第二行为输入 N 个双字节整型坐标点，共 2N 个数据，以空格分隔横纵坐标及不同的点，x1 y1 x2 y2 … xn yn… xN yN。</p><p>输出描述：<br>输出直角三角形个数。</p><p>示例1<br>输入例子：<br><br>20<br>0 0 0 3 1 2 3 4 5 6 7 8 1 4 2 4 3 5 5 0 5 5 2 0 2 2 3 0 3 3 4 5 6 1 3 7 4 0 5 2</p><p>输出例子：<br><br>165</p><p><em>代码如下：</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x[<span class="number">256</span>];</span><br><span class="line"><span class="type">int</span> y[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">distSquared</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; N; k++) &#123;</span><br><span class="line">                <span class="type">int</span> a2 = <span class="built_in">distSquared</span>(i, j);</span><br><span class="line">                <span class="type">int</span> b2 = <span class="built_in">distSquared</span>(j, k);</span><br><span class="line">                <span class="type">int</span> c2 = <span class="built_in">distSquared</span>(k, i);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Check if it forms a right triangle</span></span><br><span class="line">                <span class="keyword">if</span> (a2 + b2 == c2 || a2 + c2 == b2 || b2 + c2 == a2) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>笔试错题</title>
      <link href="/eric000.github.io/2024/07/27/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98/"/>
      <url>/eric000.github.io/2024/07/27/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>1.HTTPS协议通过使用哪些机制来确保通信的安全性（）</p><p>A 加密和身份验证</p><p>2.ETag用于标识资源的唯一标识符，它可以用于（）</p><p>A 验证资源是否发生变化</p><p>3.系统中现有一个任务进程在11:30到达系统，如果在14:30开始运行这个任务进程，其运行时间为3小时，现求这个任务进程的响应比为（）。答案：2</p><p>解析：响应比&#x3D;1+等待时间&#x2F;执行时间</p><p>4.策略模式通过定义一系列算法（在这里是运输方式），封装每一个算法，并使它们可以相互替换，特别适合于有多种类似行为或策略的系统。</p><p>工厂方法模式是一种创建型设计模式，它定义了一个用于创建对象的接口，但允许子类决定实例化哪一个类。这通常用于当一个类不能预见需要创建的对象的具体类时。</p><p>桥接模式是一种结构型设计模式，它将抽象部分与其实现部分分离，使它们可以独立变化。它的目的是“将抽象化和实现化脱耦，使得二者可以独立变化”。</p><p>适配器模式是一种结构型设计模式，它将一个类的接口转换成客户期望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>5.代码需要经过一系列步骤编译成机器指令，根据完成任务不同，可以将编译器的组成部分划分为前端与后端。下列选项是编译器前端在编译源程序时编译的顺序，正确的是（）</p><p>A 词法分析器-&gt;语法分析器-&gt;中间代码生成器</p><p>6.下列选项中只要其中一个表中存在匹配，则返回行的SQL JOIN的 类型是（）。</p><p>D FULL JOIN</p>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/eric000.github.io/2024/07/26/%E8%B4%AA%E5%BF%83/"/>
      <url>/eric000.github.io/2024/07/26/%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="一文读懂贪心算法"><a href="#一文读懂贪心算法" class="headerlink" title="一文读懂贪心算法"></a>一文读懂贪心算法</h1><h2 id="概念及使用"><a href="#概念及使用" class="headerlink" title="概念及使用"></a>概念及使用</h2><p>贪心算法或贪心思想采用贪心的策略，保证每次操作都是<strong>局部最优</strong>，从而使最后得到的结果是<strong>全局最优</strong>的</p><p>通常不使用回溯</p><p><strong>适用条件：</strong><br>1.问题具有最优子结构性质：问题的最优解可以通过子问题的最优解推导得到。<br>2.贪心选择性质：每一步的选择都是当前状态下的最优解，即局部最优。</p><p><strong>优缺点：</strong><br>优点： 算法简单、高效，适用于一些问题，尤其是最优子结构和贪心选择性质明显的情况。<br>缺点： 不适用于所有问题，可能得不到全局最优解，只能得到局部最优解或者近似最优解。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h3><p>        <span class="lazyload-img-span">        <img              data-src="https://raw.githubusercontent.com/Itsbaikai/eric000.github.io/main/images/fenpei.jpg" class="lazyload-img">        </sapn>      </p><p>解题思路：</p><p>        <span class="lazyload-img-span">        <img              data-src="https://raw.githubusercontent.com/Itsbaikai/eric000.github.io/main/images/fenpeitijie.jpg" class="lazyload-img">        </sapn>      </p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="type">int</span> g[], <span class="type">int</span> gSize, <span class="type">int</span> s[], <span class="type">int</span> sSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对孩子的饥饿度和饼干的大小进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(g, g + gSize);</span><br><span class="line">    <span class="built_in">sort</span>(s, s + sSize);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> childIndex = <span class="number">0</span>; <span class="comment">// 孩子的索引</span></span><br><span class="line">    <span class="type">int</span> cookieIndex = <span class="number">0</span>; <span class="comment">// 饼干的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历饥饿度和饼干大小，尝试满足孩子</span></span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; gSize &amp;&amp; cookieIndex &lt; sSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[cookieIndex] &gt;= g[childIndex]) &#123;</span><br><span class="line">            <span class="comment">// 当前饼干可以满足当前孩子的饥饿度</span></span><br><span class="line">            childIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无论是否满足孩子，饼干索引都需要移动</span></span><br><span class="line">        cookieIndex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> childIndex; <span class="comment">// 最终满足的孩子数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> g[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 孩子的饥饿度</span></span><br><span class="line">    <span class="type">int</span> s[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 饼干的大小</span></span><br><span class="line">    <span class="type">int</span> gSize = <span class="built_in">sizeof</span>(g) / <span class="built_in">sizeof</span>(g[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> sSize = <span class="built_in">sizeof</span>(s) / <span class="built_in">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">findContentChildren</span>(g, gSize, s, sSize);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最多有&quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;个孩子可以吃饱。&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="【深基12-例1】部分背包问题"><a href="#【深基12-例1】部分背包问题" class="headerlink" title="【深基12.例1】部分背包问题"></a>【深基12.例1】部分背包问题</h3><p>链接：<a href="https://www.luogu.com.cn/problem/P2240">https://www.luogu.com.cn/problem/P2240</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\le m_i,v_i \le 100)$。阿里巴巴有一个承重量为 $T(T \le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数 $N,T$。</p><p>接下来 $N$ 行，每行两个整数 $m_i,v_i$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个实数表示答案，输出两位小数</p><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h4><h5 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 50</span><br><span class="line">10 60</span><br><span class="line">20 100</span><br><span class="line">30 120</span><br><span class="line">15 45</span><br></pre></td></tr></table></figure><h5 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">240.00</span><br></pre></td></tr></table></figure><p>解题思路：使用贪心算法那首先想到金币按照价值的高低排序，先装价值高的。又因为是可以分割的，可以知道应该以价格的单位价值为分类标准，所以在获取输入时候就可以把单位价值计算出来。<br>又因为金币的性质很多，所以用到结构体，排序用sort函数，定义compare。<br>那就循环遍历数组，依次累加价值，直到价值超过了背包。超过背包也不能直接return，要看是不是有剩余的价值（也就是拆开的金子）<br>最后就可以直接输出了 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GoldPile</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">double</span> unit_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(GoldPile a, GoldPile b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.unit_value &gt; b.unit_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N, T;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    GoldPile gold[N];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        cin &gt;&gt; gold[i].weight &gt;&gt; gold[i].value;</span><br><span class="line">        gold[i].unit_value = (<span class="type">double</span>)gold[i].value / gold[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(gold, gold + N, compare);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> max_value = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> current_weight = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N &amp;&amp; current_weight &lt; T; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current_weight + gold[i].weight &lt;= T) &#123;</span><br><span class="line">            current_weight += gold[i].weight;</span><br><span class="line">            max_value += gold[i].value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> remaining_weight = T - current_weight;</span><br><span class="line">            max_value += remaining_weight * gold[i].unit_value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; max_value &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="凌乱的yyy-线段覆盖"><a href="#凌乱的yyy-线段覆盖" class="headerlink" title="凌乱的yyy &#x2F; 线段覆盖"></a>凌乱的yyy &#x2F; 线段覆盖</h3><p>links： <a href="https://www.luogu.com.cn/problem/P1803">https://www.luogu.com.cn/problem/P1803</a></p><h4 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h4><p>快 noip 了，yyy 很紧张！</p><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>现在各大 oj 上有 $n$ 个比赛，每个比赛的开始、结束的时间点是知道的。</p><p>yyy 认为，参加越多的比赛，noip 就能考的越好（假的）。</p><p>所以，他想知道他最多能参加几个比赛。</p><p>由于 yyy 是蒟蒻，如果要参加一个比赛必须善始善终，而且不能同时参加 $2$ 个及以上的比赛。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是一个整数 $n$，接下来 $n$ 行每行是 $2$ 个整数 $a_{i},b_{i}\ (a_{i}&lt;b_{i})$，表示比赛开始、结束的时间。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个整数最多参加的比赛数目。</p><h4 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h4><h5 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 2</span><br><span class="line">2 4</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h5 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><ul><li>对于 $20%$ 的数据，$n \le 10$；</li><li>对于 $50%$ 的数据，$n \le 10^3$；</li><li>对于 $70%$ 的数据，$n \le 10^{5}$；</li><li>对于 $100%$ 的数据，$1\le n \le 10^{6}$，$0 \le a_{i} &lt; b_{i} \le 10^6$。</li></ul><p>解题思路：思路很简单<br>以结束时间进行排序，再进行贪心。遍历每个比赛，如果当前比赛的开始时间大于上一个比赛的结束时间，那么就可以比了。<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比赛结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于按结束时间排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Event a, Event b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.end &lt; b.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    Event events[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入比赛的开始和结束时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; events[i].start &gt;&gt; events[i].end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按结束时间排序</span></span><br><span class="line">    <span class="built_in">sort</span>(events, events + n, compare);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;           <span class="comment">// 记录最多能参加的比赛数</span></span><br><span class="line">    <span class="type">int</span> last_end_time = <span class="number">-1</span>;  <span class="comment">// 记录上一个选中比赛的结束时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 贪心选择不重叠的比赛</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].start &gt;= last_end_time) &#123;</span><br><span class="line">            <span class="comment">// 选择当前比赛</span></span><br><span class="line">            count++;</span><br><span class="line">            last_end_time = events[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pair用法</title>
      <link href="/eric000.github.io/2024/07/23/pair%E7%94%A8%E6%B3%95/"/>
      <url>/eric000.github.io/2024/07/23/pair%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="pair定义"><a href="#pair定义" class="headerlink" title="pair定义"></a>pair定义</h3><p>pair可以看作是定义了一个结构体，有两个值，分别为first和second<br>其标准库类型-定义在#include <utility> 头文件中</p><h3 id="pair使用场景"><a href="#pair使用场景" class="headerlink" title="pair使用场景"></a>pair使用场景</h3><p>pair是将<strong>2个数据组合成一组数据</strong>,当需要这样的需求时就可以使用pair<br>比如：需要将数组的序号和存储的值排序以后分别输出，这个时候就可以用pair更加方便。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在创建pair对象时，<strong>必须提供两个类型名</strong>，两个对应的类型名的类型不必相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; word;        <span class="comment">// 创建一个空对象anon，两个元素类型都是string</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; cnt;     <span class="comment">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt; &gt; line;  <span class="comment">// 创建一个空对象line，两个元素类型分别是string和vector类型</span></span><br></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>与结构体一样，使用**.属性**来进行访问，两个属性first和second</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">p<span class="number">1.f</span>irst = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line">p<span class="number">1.</span>second = <span class="number">6</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><h3 id="排队接水"><a href="#排队接水" class="headerlink" title="排队接水"></a>排队接水</h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为一个整数 $n$。</p><p>第二行 $n$ 个整数，第 $i$ 个整数 $T_i$ 表示第 $i$ 个人的接水时间 $T_i$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。</p><h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h3><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 </span><br><span class="line">56 12 1 99 1000 234 33 55 99 812</span><br></pre></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 2 7 8 1 4 9 6 10 5</span><br><span class="line">291.90</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。</p><p>思路都是用来存序号和等待打水的时间，pair里存的是first和second，第一个未使用的是struct</p><p>未使用pair使用结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">water</span>&#123;</span><br><span class="line"><span class="type">int</span> time;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(water a,water b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.time&lt;b.time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">water a[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">cin&gt;&gt;a[i].time;</span><br><span class="line">a[i].num=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>,compare);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">cout&lt;&lt;a[i].num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="type">double</span> wait_time=<span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> sum=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sum+=wait_time;</span><br><span class="line">wait_time+=a[i].time;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; sum/n &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用pair以后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个数组来存储每个人的接水时间和初始位置</span></span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; times[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; times[i].second;</span><br><span class="line">        times[i].first = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按接水时间从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(times, times + n, compare);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> total_wait_time = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">double</span> current_wait_time = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排队顺序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; times[i].first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        total_wait_time += current_wait_time;</span><br><span class="line">        current_wait_time += times[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并输出平均等待时间</span></span><br><span class="line">    <span class="type">double</span> average_wait_time = total_wait_time / n;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; average_wait_time &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>因果</title>
      <link href="/eric000.github.io/2024/07/21/%E5%9B%A0%E6%9E%9C/"/>
      <url>/eric000.github.io/2024/07/21/%E5%9B%A0%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p>因果是世界上最切实际的理论，任何事情的发生或结束都有因果。<br>并且因果会超过时间、空间等一切，辩证求因，逐本溯源。</p><p>比如：有的女生会感到痛经，可能是因为前一段时间每天都吃雪糕，都喝冰水。当时可能没有什么影响，但是最后还是会显现出作用。</p><p>公园二十分钟的中医解释：<br>1.公园里有绿植，木气更重一些，且木主生发<br>2.白天出门，能晒太阳，生发阳气，木气更有助于生发阳气。</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建过程</title>
      <link href="/eric000.github.io/2024/07/20/text/"/>
      <url>/eric000.github.io/2024/07/20/text/</url>
      
        <content type="html"><![CDATA[<p>        <span class="lazyload-img-span">        <img              data-src="https://raw.githubusercontent.com/Itsbaikai/eric000.github.io/main/images/blog_test.jpg" class="lazyload-img">        </sapn>      </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.15</title>
      <link href="/eric000.github.io/2024/07/19/1111/"/>
      <url>/eric000.github.io/2024/07/19/1111/</url>
      
        <content type="html"><![CDATA[<p>痛苦本身是舒适区，积极情绪是习得的</p><p>希望每一次比赛和考试，都能以“以赛代练”的心态来完成</p><p>认知创造了你所栖息的那一层现实</p><p>推荐一本书《自控力》</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown测试</title>
      <link href="/eric000.github.io/2024/07/18/blog/"/>
      <url>/eric000.github.io/2024/07/18/blog/</url>
      
        <content type="html"><![CDATA[<h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>&#x3D;&#x3D;标记文本&#x3D;&#x3D;</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>图片:         <span class="lazyload-img-span">        <img              data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" class="lazyload-img">        </sapn>      </p><p>居中的图片:         <span class="lazyload-img-span">        <img              data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" class="lazyload-img">        </sapn>      </p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/console/configBlog">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An highlighted block</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：</p><table><thead><tr><th>项目</th><th>Value</th></tr></thead><tbody><tr><td>电脑</td><td>$1600</td></tr><tr><td>手机</td><td>$12</td></tr><tr><td>导管</td><td>$1</td></tr></tbody></table><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右</p><table><thead><tr><th align="center">第一列</th><th align="right">第二列</th><th align="left">第三列</th></tr></thead><tbody><tr><td align="center">第一列文本居中</td><td align="right">第二列文本居右</td><td align="left">第三列文本居左</td></tr></tbody></table><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：</p><table><thead><tr><th>TYPE</th><th>ASCII</th><th>HTML</th></tr></thead><tbody><tr><td>Single backticks</td><td><code>&#39;Isn&#39;t this fun?&#39;</code></td><td>‘Isn’t this fun?’</td></tr><tr><td>Quotes</td><td><code>&quot;Isn&#39;t this fun?&quot;</code></td><td>“Isn’t this fun?”</td></tr><tr><td>Dashes</td><td><code>-- is en-dash, --- is em-dash</code></td><td>– is en-dash, — is em-dash</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>评论测试</title>
      <link href="/eric000.github.io/2024/07/17/First-blog/"/>
      <url>/eric000.github.io/2024/07/17/First-blog/</url>
      
        <content type="html"><![CDATA[<p>测试</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
